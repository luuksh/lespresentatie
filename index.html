<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Klassenplattegrond</title>

  <link rel="stylesheet" href="css/style.css?v=20260222-9" />

  <script type="module" src="js/indeling.js?v=20260222-9"></script>
  <script type="module" src="js/init.js?v=20260222-9"></script>
</head>
<body>
  <section id="opdrachtMount" class="opdracht-board" role="region" aria-label="Lesopdracht op bord">
    <p class="opdracht-label">Opdracht op bord</p>
    <div class="opdracht-menu">
      <select id="opdrachtSelect" aria-label="Kies een opdracht">
        <option>Lees in je leesboek</option>
        <option>Zoek je plek en pak je spullen</option>
        <option>Werk aan de opdracht. Klaar? Lees in je leesboek.</option>
        <option>Overleg in tweetallen</option>
        <option>Bereid je presentatie voor</option>
      </select>
    </div>
  </section>

  <button id="drawerQuickToggle" class="drawer-quick-toggle" type="button" aria-label="Toon of verberg docentpaneel">
    Docentpaneel
  </button>

  <aside class="side-drawer left" aria-label="Docentpaneel">
    <button class="drawer-handle" aria-label="Open docentpaneel">Docent</button>
    <div class="drawer-content">
      <section class="card control-card">
        <h2 class="panel-title">Sessiebediening</h2>
        <p class="panel-help">Deze knoppen zijn voor de docent en niet bedoeld voor leerlingen.</p>

        <div class="controls-row">
          <button id="save-absenties-btn" type="button" class="btn btn-primary">Opslaan absenties</button>
          <button id="toggle-view-btn" type="button" class="btn btn-secondary">Docentweergave (spiegel)</button>
          <button id="btnPrintLayoutDrawer" type="button" class="btn btn-secondary">Print / PDF</button>
        </div>

        <div id="save-status" class="status-text"></div>
      </section>

      <section class="card control-card">
        <h2 class="panel-title">Opstellingen</h2>

        <div class="toolbar presets-panel">
          <span class="presets-label">Preset</span>
          <select id="presetSelect" class="presets-select"></select>

          <div class="btn-group">
            <button id="btnPresetLoad" class="btn btn-secondary">Laden</button>
            <button id="btnPresetSave" class="btn btn-primary">Opslaan als…</button>
            <button id="btnPresetOverwrite" class="btn btn-secondary">Overschrijven</button>
          </div>

          <div class="btn-group">
            <button id="btnPresetRename" class="btn btn-secondary">Hernoemen</button>
            <button id="btnPresetDelete" class="btn btn-danger">Verwijderen</button>
          </div>

          <div class="btn-group">
            <button id="btnPresetExport" class="btn btn-secondary">Export .doc</button>
            <label for="presetImport" class="btn btn-secondary import-label">Import JSON</label>
          </div>

          <input id="presetImport" type="file" accept="application/json" hidden />
        </div>
      </section>
    </div>
  </aside>

  <main class="layout" id="layoutRoot">
    <div class="board-scaler" id="boardScaler">
      <section class="plattegrond-frame" id="plattegrondFrame">
        <div class="print-meta" id="printMeta"></div>

        <div class="topbar" aria-label="Lesinstellingen">
          <div class="controls-row controls-row-main">
            <div class="field">
              <span class="label">Indeling</span>
              <select id="indelingSelect">
                <option value="h216">Busopstelling</option>
                <option value="u008">3-3-2</option>
                <option value="drievierdrie">3-4-3</option>
                <option value="drietallen">Drietallen</option>
                <option value="groepjes">Viertallen</option>
                <option value="vijftallen">Vijftallen</option>
                <option value="presentatievolgorde">Volgorde</option>
              </select>
            </div>

            <div class="field">
              <span class="label">Klas</span>
              <select id="klasSelect"></select>
            </div>

            <div class="lesson-status in-topbar" id="lessonStatusBar">
              <span class="status-chip" id="currentClassLabel">Klas: -</span>
              <span class="status-chip" id="currentLayoutLabel">Indeling: -</span>
            </div>

            <div class="controls-row quick-board-actions">
              <button id="btnPrintLayout" type="button" class="btn btn-secondary">Print / PDF</button>
            </div>
          </div>
        </div>

        <div class="grid-wrapper">
          <div class="bureau-rij">
            <div class="leraar-bureau">Bureau leraar</div>
          </div>
          <div class="grid" id="plattegrond"></div>
        </div>
      </section>
    </div>
  </main>

  <aside id="timerDock" class="clock-timer" role="timer" aria-live="polite">
    <div class="clock-wrap">
      <div class="clock-face" id="clockFace" aria-label="Aftelklok">
        <div class="clock-bezel"></div>
        <div class="clock-progress" id="clockProgress"></div>
        <div class="clock-dial" id="clockDial"></div>
        <div class="clock-hand" id="clockHand"></div>
        <div class="clock-hub"></div>
        <div class="clock-numeral n12">12</div>
        <div class="clock-numeral n3">3</div>
        <div class="clock-numeral n6">6</div>
        <div class="clock-numeral n9">9</div>
        <div class="clock-digital">
          <div class="clock-time" id="clockTime">05:00</div>
          <div class="clock-state" id="clockState">Gepauzeerd</div>
        </div>
      </div>
      <div class="timer-hotkeys">spatie start/pauze · R/Esc reset</div>
    </div>

  </aside>

  <script>
    (() => {
      const GRID_ID = 'plattegrond';
      const CARD_SELECTOR = '.tafel, .seat, .student, .desk-item, .naamkaartje, .kaartje, .student-card, .desk';
      const roomSel = document.getElementById('indelingSelect');
      const classSel = document.getElementById('klasSelect');

      function clearUI() {
        document.querySelectorAll(`#${GRID_ID} ${CARD_SELECTOR}.is-absent`).forEach(el => el.classList.remove('is-absent'));
      }

      function attachDelegatedClick() {
        const grid = document.getElementById(GRID_ID);
        if (!grid) return;
        grid.addEventListener('click', (e) => {
          const card = e.target.closest(CARD_SELECTOR);
          if (!card || !grid.contains(card)) return;
          card.classList.toggle('is-absent');
        });
      }

      function watchGridChanges() {
        const grid = document.getElementById(GRID_ID);
        if (!grid) return;
        const mo = new MutationObserver(() => clearUI());
        mo.observe(grid, { childList: true, subtree: true });
      }

      ['change', 'click', 'input'].forEach(evt => {
        roomSel?.addEventListener(evt, () => setTimeout(clearUI, 0));
        classSel?.addEventListener(evt, () => setTimeout(clearUI, 0));
      });

      window.addEventListener('pageshow', () => setTimeout(clearUI, 0));

      const init = () => {
        attachDelegatedClick();
        watchGridChanges();
        setTimeout(clearUI, 0);
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>

  <script>
    (() => {
      const GRID_ID = 'plattegrond';
      const SEAT_SELECTOR = '.tafel';
      let sourceSeat = null;

      function clearDragState(grid) {
        if (!grid) return;
        grid.querySelectorAll(`${SEAT_SELECTOR}.drag-source, ${SEAT_SELECTOR}.drag-target`)
          .forEach(el => el.classList.remove('drag-source', 'drag-target'));
      }

      function initDraggableSeats() {
        document.querySelectorAll(`#${GRID_ID} ${SEAT_SELECTOR}`).forEach(el => {
          el.draggable = true;
        });
      }

      function swapSeats(a, b) {
        if (!a || !b || a === b) return;

        const aText = a.textContent;
        const bText = b.textContent;

        const aAbsent = a.classList.contains('is-absent');
        const bAbsent = b.classList.contains('is-absent');

        a.textContent = bText;
        b.textContent = aText;

        a.classList.toggle('is-absent', bAbsent);
        b.classList.toggle('is-absent', aAbsent);
      }

      function initDnD() {
        const grid = document.getElementById(GRID_ID);
        if (!grid) return;

        initDraggableSeats();

        grid.addEventListener('dragstart', (e) => {
          const seat = e.target.closest(SEAT_SELECTOR);
          if (!seat || !grid.contains(seat)) return;

          sourceSeat = seat;
          seat.classList.add('drag-source');

          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', seat.dataset.seatId || '');
        });

        grid.addEventListener('dragover', (e) => {
          const seat = e.target.closest(SEAT_SELECTOR);
          if (!seat || !sourceSeat || seat === sourceSeat) return;

          e.preventDefault();
          seat.classList.add('drag-target');
          e.dataTransfer.dropEffect = 'move';
        });

        grid.addEventListener('dragleave', (e) => {
          const seat = e.target.closest(SEAT_SELECTOR);
          if (!seat) return;
          seat.classList.remove('drag-target');
        });

        grid.addEventListener('drop', (e) => {
          const targetSeat = e.target.closest(SEAT_SELECTOR);
          if (!sourceSeat || !targetSeat || sourceSeat === targetSeat) return;

          e.preventDefault();
          swapSeats(sourceSeat, targetSeat);

          clearDragState(grid);
          sourceSeat = null;
        });

        grid.addEventListener('dragend', () => {
          clearDragState(grid);
          sourceSeat = null;
        });

        const mo = new MutationObserver(() => initDraggableSeats());
        mo.observe(grid, { childList: true, subtree: true });
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initDnD);
      } else {
        initDnD();
      }
    })();
  </script>

  <script>
    (() => {
      const GRID_ID = 'plattegrond';
      const CARD = '.tafel';
      const klasSel = document.getElementById('klasSelect');
      const statusEl = document.getElementById('save-status');
      const key = `absenties_${new Date().toISOString().slice(0, 10)}`;

      function nowNL() {
        return new Intl.DateTimeFormat('nl-NL', {
          year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit'
        }).format(new Date());
      }

      function getAbsentNames() {
        return Array.from(document.querySelectorAll(`#${GRID_ID} ${CARD}.is-absent`))
          .map(el => el.innerText.trim())
          .filter(Boolean);
      }

      function flash(msg) {
        if (!statusEl) return;
        statusEl.textContent = msg;
        statusEl.style.opacity = '1';
        clearTimeout(flash.t);
        flash.t = setTimeout(() => { statusEl.style.opacity = '0'; }, 2600);
      }

      function saveSnapshot() {
        const klas = klasSel?.value || 'onbekend';
        const names = getAbsentNames();
        let all = [];
        try { all = JSON.parse(localStorage.getItem(key)) || []; } catch {}

        const others = all.filter(e => e && e.klas !== klas);

        if (names.length === 0) {
          localStorage.setItem(key, JSON.stringify(others));
          flash(`Leeg gemaakt voor ${klas} (${nowNL()})`);
          return;
        }

        const entry = { klas, datetime: new Date().toISOString(), names };
        others.push(entry);
        localStorage.setItem(key, JSON.stringify(others));
        flash(`Opgeslagen (${names.length}) voor ${klas} om ${nowNL()}`);
      }

      document.getElementById('save-absenties-btn')?.addEventListener('click', saveSnapshot);
    })();
  </script>

  <script>
    (() => {
      const container = document.getElementById('plattegrondFrame');
      const btn = document.getElementById('toggle-view-btn');
      const LS_KEY = 'mirror_view_enabled';
      const indelingSel = document.getElementById('indelingSelect');
      const klasSel = document.getElementById('klasSelect');

      function setMirror(on) {
        container?.classList.toggle('mirror', on);
        try { localStorage.setItem(LS_KEY, on ? '1' : '0'); } catch {}
        if (btn) btn.textContent = on ? 'Leerlingenweergave' : 'Docentweergave (spiegel)';
      }

      function applyFromStorage() {
        setMirror(localStorage.getItem(LS_KEY) === '1');
      }

      function toggleMirror() {
        setMirror(!container?.classList.contains('mirror'));
      }

      btn?.addEventListener('click', toggleMirror);
      indelingSel?.addEventListener('change', () => setMirror(false));
      klasSel?.addEventListener('change', () => setMirror(false));

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', applyFromStorage);
      } else {
        applyFromStorage();
      }
    })();
  </script>

  <script>
    (() => {
      const btnHeaderPrint = document.getElementById('btnPrintLayout');
      const btnDrawerPrint = document.getElementById('btnPrintLayoutDrawer');
      const body = document.body;
      const indelingSel = document.getElementById('indelingSelect');
      const klasSel = document.getElementById('klasSelect');
      const printMeta = document.getElementById('printMeta');
      const quickToggle = document.getElementById('drawerQuickToggle');
      const currentClassLabel = document.getElementById('currentClassLabel');
      const currentLayoutLabel = document.getElementById('currentLayoutLabel');
      const boardScaler = document.getElementById('boardScaler');
      const boardFrame = document.getElementById('plattegrondFrame');
      const layoutRoot = document.getElementById('layoutRoot');
      const grid = document.getElementById('plattegrond');

      function nowNL() {
        return new Intl.DateTimeFormat('nl-NL', {
          year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit'
        }).format(new Date());
      }

      function updateBoardLabels() {
        const indeling = indelingSel?.selectedOptions?.[0]?.textContent?.trim() || '-';
        const klas = klasSel?.selectedOptions?.[0]?.textContent?.trim() || '-';

        if (currentClassLabel) currentClassLabel.textContent = `Klas: ${klas}`;
        if (currentLayoutLabel) currentLayoutLabel.textContent = `Indeling: ${indeling}`;

        printMeta.textContent = `Klassenplattegrond · ${klas} · ${indeling} · ${nowNL()}`;
      }

      function fitBoardToViewport() {
        if (!boardScaler || !boardFrame || !layoutRoot) return;

        boardFrame.style.transform = 'scale(1)';
        boardScaler.style.height = 'auto';

        const naturalW = boardFrame.scrollWidth;
        const naturalH = boardFrame.scrollHeight;

        const top = boardScaler.getBoundingClientRect().top;
        const maxH = Math.max(220, window.innerHeight - top - 8);
        const maxW = Math.max(320, layoutRoot.clientWidth - 2);

        const scale = Math.min(1, maxW / naturalW, maxH / naturalH);

        boardFrame.style.transform = `scale(${scale})`;
        boardFrame.style.transformOrigin = 'top center';

        boardScaler.style.width = `${Math.min(maxW, naturalW * scale)}px`;
        boardScaler.style.height = `${naturalH * scale}px`;
      }

      function runPrint() {
        updateBoardLabels();
        window.print();
      }

      function toggleDrawerPin() {
        body.classList.toggle('drawer-open');
      }

      btnHeaderPrint?.addEventListener('click', runPrint);
      btnDrawerPrint?.addEventListener('click', runPrint);
      quickToggle?.addEventListener('click', toggleDrawerPin);

      indelingSel?.addEventListener('change', () => {
        updateBoardLabels();
        setTimeout(fitBoardToViewport, 80);
      });

      klasSel?.addEventListener('change', () => {
        updateBoardLabels();
        setTimeout(fitBoardToViewport, 80);
      });

      window.addEventListener('resize', fitBoardToViewport);

      document.addEventListener('keydown', (e) => {
        if ((e.key === 'd' || e.key === 'D')) {
          toggleDrawerPin();
        }
      });

      if (grid) {
        const mo = new MutationObserver(() => setTimeout(fitBoardToViewport, 30));
        mo.observe(grid, { childList: true, subtree: true });
      }

      window.fitBoardToViewport = fitBoardToViewport;

      updateBoardLabels();
      setTimeout(fitBoardToViewport, 60);
    })();
  </script>

  <script>
    (() => {
      const opdrachtSelect = document.getElementById('opdrachtSelect');
      if (!opdrachtSelect) return;

      function fitToLongest() {
        const probe = document.createElement('span');
        probe.style.cssText = 'position:absolute;visibility:hidden;white-space:nowrap;left:-9999px;top:-9999px;';
        document.body.appendChild(probe);

        const cs = getComputedStyle(opdrachtSelect);
        probe.style.font = cs.font;

        let longest = '';
        for (const option of opdrachtSelect.options) {
          if (option.text.length > longest.length) longest = option.text;
        }

        probe.textContent = longest;
        const wrap = opdrachtSelect.closest('.opdracht-menu');
        const available = wrap ? wrap.clientWidth : window.innerWidth * 0.9;
        const needed = probe.offsetWidth + 120;
        opdrachtSelect.style.width = `${Math.min(available, needed)}px`;
        probe.remove();
      }

      fitToLongest();
      window.addEventListener('resize', fitToLongest);
      opdrachtSelect.addEventListener('change', fitToLongest);
    })();
  </script>

  <script>
    (() => {
      let total = 300;
      let remaining = total;
      let running = false;
      let intervalId = null;

      const clockFace = document.getElementById('clockFace');
      const progress = document.getElementById('clockProgress');
      const hand = document.getElementById('clockHand');
      const timeEl = document.getElementById('clockTime');
      const stateEl = document.getElementById('clockState');
      const startBtn = null;
      const resetBtn = null;
      const applyBtn = null;
      const minIn = null;
      const secIn = null;

      const dial = document.getElementById('clockDial');
      const timerDock = document.getElementById('timerDock');

      if (!clockFace || !progress || !hand || !timeEl || !stateEl || !dial) return;

      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

      function fmt(seconds) {
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
      }

      function syncInputsFrom(value) {
        const m = Math.floor(value / 60);
        const s = value % 60;
        if (minIn) minIn.value = String(m);
        if (secIn) secIn.value = String(s);
      }

      function updateDigits() {
        timeEl.textContent = fmt(remaining);
        if (remaining === 0 && !running) {
          stateEl.textContent = 'Klaar';
        } else {
          stateEl.textContent = running ? 'Bezig' : 'Gepauzeerd';
        }
      }

      function updateClock() {
        const done = total > 0 ? (total - remaining) / total : 0;
        progress.style.setProperty('--pct', (done * 100).toFixed(4));
        hand.style.setProperty('--angle', `${(done * 360).toFixed(4)}deg`);
        clockFace.classList.toggle('done', remaining === 0);
      }

      function setByAngle(clientX, clientY) {
        if (total <= 0) total = 300;
        const rect = clockFace.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        const dx = clientX - cx;
        const dy = clientY - cy;
        let angle = Math.atan2(dy, dx) * (180 / Math.PI) + 90;
        if (angle < 0) angle += 360;
        const done = angle / 360;
        remaining = clamp(Math.round(total * (1 - done)), 0, total);
        syncInputsFrom(remaining);
        updateDigits();
        updateClock();
      }

      function setFromInputs() {
        const m = clamp(parseInt(minIn?.value, 10) || 0, 0, 999);
        const s = clamp(parseInt(secIn?.value, 10) || 0, 0, 59);
        total = m * 60 + s;
        remaining = total;
        running = false;
        clearInterval(intervalId);
        if (startBtn) startBtn.textContent = 'Start';
        updateDigits();
        updateClock();
      }

      function applyPreset(delta) {
        const next = clamp(remaining + delta, 0, 999 * 60 + 59);
        remaining = next;
        if (!running) total = next;
        syncInputsFrom(!running ? total : remaining);
        updateDigits();
        updateClock();
      }

      function tick() {
        if (!running) return;
        if (remaining <= 0) {
          clearInterval(intervalId);
          running = false;
          if (startBtn) startBtn.textContent = 'Start';
          updateDigits();
          updateClock();
          if (navigator.vibrate) navigator.vibrate([180, 90, 180]);
          return;
        }
        remaining -= 1;
        updateDigits();
        updateClock();
      }

      function start() {
        if (remaining <= 0 && total > 0) remaining = total;
        if (remaining <= 0) return;
        running = true;
        if (startBtn) startBtn.textContent = 'Pauze';
        clearInterval(intervalId);
        intervalId = setInterval(tick, 1000);
        updateDigits();
      }

      function pause() {
        running = false;
        clearInterval(intervalId);
        if (startBtn) startBtn.textContent = 'Start';
        updateDigits();
      }

      function reset() {
        running = false;
        clearInterval(intervalId);
        remaining = total;
        if (startBtn) startBtn.textContent = 'Start';
        syncInputsFrom(total);
        updateDigits();
        updateClock();
      }

      startBtn?.addEventListener('click', () => (running ? pause() : start()));
      resetBtn?.addEventListener('click', reset);
      applyBtn?.addEventListener('click', setFromInputs);

      document.addEventListener('keydown', (e) => {
        const hardReload = (e.metaKey || e.ctrlKey) && e.shiftKey && e.code === 'KeyR';
        if (hardReload) {
          window.location.reload();
          return;
        }

        const activeTag = document.activeElement?.tagName;
        if (activeTag === 'INPUT' || document.activeElement?.isContentEditable) return;
        if (e.code === 'Space') {
          e.preventDefault();
          running ? pause() : start();
        }
        const plainR = e.code === 'KeyR' && !e.metaKey && !e.ctrlKey && !e.altKey && !e.shiftKey;
        if (plainR || e.code === 'Escape') {
          e.preventDefault();
          reset();
        }
      });

      for (let i = 0; i < 60; i++) {
        const tickEl = document.createElement('div');
        tickEl.className = `clock-tick${i % 5 === 0 ? ' big' : ''}`;
        tickEl.style.transform = `translateX(-50%) rotate(${i * 6}deg)`;
        dial.appendChild(tickEl);
      }

      let interactionMode = null;
      let dragOffsetX = 0;
      let dragOffsetY = 0;

      function isNearClockEdge(clientX, clientY) {
        const rect = clockFace.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        const dx = clientX - cx;
        const dy = clientY - cy;
        const dist = Math.hypot(dx, dy);
        const radius = Math.min(rect.width, rect.height) / 2;
        const edgeBand = 18;
        return dist >= radius - edgeBand && dist <= radius + 10;
      }

      function moveDock(clientX, clientY) {
        if (!timerDock) return;
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const dockRect = timerDock.getBoundingClientRect();
        const maxLeft = Math.max(0, vw - dockRect.width);
        const maxTop = Math.max(0, vh - dockRect.height);
        const left = clamp(clientX - dragOffsetX, 0, maxLeft);
        const top = clamp(clientY - dragOffsetY, 0, maxTop);
        timerDock.style.left = `${left}px`;
        timerDock.style.top = `${top}px`;
      }

      function setEdgeCursor(clientX, clientY) {
        if (interactionMode) return;
        clockFace.classList.toggle('edge-draggable', isNearClockEdge(clientX, clientY));
      }

      const stopInteraction = () => {
        interactionMode = null;
        clockFace.classList.remove('dragging-dock');
      };

      clockFace.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        clockFace.setPointerCapture(e.pointerId);

        const canDragDock = timerDock && getComputedStyle(timerDock).position === 'fixed';
        if (canDragDock && isNearClockEdge(e.clientX, e.clientY)) {
          interactionMode = 'dock-drag';
          const dockRect = timerDock.getBoundingClientRect();
          timerDock.style.right = 'auto';
          timerDock.style.bottom = 'auto';
          timerDock.style.left = `${dockRect.left}px`;
          timerDock.style.top = `${dockRect.top}px`;
          dragOffsetX = e.clientX - dockRect.left;
          dragOffsetY = e.clientY - dockRect.top;
          clockFace.classList.add('dragging-dock');
          moveDock(e.clientX, e.clientY);
          return;
        }

        interactionMode = 'scrub';
        if (running) pause();
        setByAngle(e.clientX, e.clientY);
      });
      clockFace.addEventListener('pointermove', (e) => {
        if (interactionMode === 'dock-drag') {
          moveDock(e.clientX, e.clientY);
          return;
        }
        if (interactionMode !== 'scrub') {
          setEdgeCursor(e.clientX, e.clientY);
          return;
        }
        setByAngle(e.clientX, e.clientY);
      });
      clockFace.addEventListener('pointerup', stopInteraction);
      clockFace.addEventListener('pointercancel', stopInteraction);
      clockFace.addEventListener('pointerleave', () => {
        if (!interactionMode) clockFace.classList.remove('edge-draggable');
      });

      syncInputsFrom(total);
      updateDigits();
      updateClock();
    })();
  </script>

  <script>
    window.addEventListener('load', () => {
      setTimeout(() => window.fitBoardToViewport?.(), 100);
    });
  </script>
</body>
</html>
